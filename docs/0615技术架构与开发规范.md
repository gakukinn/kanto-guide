# Kanto Travel Guide 技术架构与开发规范

_文档更新时间: 2025-06-15_  
_文档类型: 技术规范 | 开发指南_

## 🏗️ 技术架构概览

### 核心技术栈

```typescript
// 主要技术组合
Frontend: Next.js 15.3.3 + TypeScript + Tailwind CSS
Architecture: 4层静态站点架构
Pages: 147个静态页面
Data Sources: omaturilink.com (matsuri) + walkerplus.com (hanabi)
Quality: 自动化质量检查系统
```

### 项目结构

```
kanto-travel-guide/
├── src/
│   ├── app/                    # Next.js App Router页面
│   │   ├── tokyo/hanabi/       # 东京花火页面
│   │   ├── tokyo/matsuri/      # 东京祭典页面
│   │   └── [region]/[activity]/ # 其他地区页面
│   ├── components/             # 共用组件
│   │   ├── HanabiPageTemplate.tsx
│   │   └── MatsuriPageTemplate.tsx
│   └── data/                   # 静态数据文件
├── docs/                       # 项目文档
├── scripts/                    # 构建和质量检查脚本
└── package.json               # 项目配置
```

## 📋 页面模板系统

### MatsuriPageTemplate 使用规范

**适用场景:** 传统祭典页面  
**数据来源:** omaturilink.com  
**核心特点:** 文化传承、传统艺能、历史背景

```typescript
// 标准配置格式
const regionConfig = {
  name: 'region-code', // 英文地区代码
  displayName: '中文名称', // 显示名称
  emoji: '🎌', // 代表性emoji
  description: '地区文化描述', // 详细描述
  navigationLinks: {
    prev: { name: '前页', url: '/prev', emoji: '🎭' },
    next: { name: '后页', url: '/next', emoji: '🎪' },
    current: { name: '当前', url: '/current' },
  },
};

// 标准事件数据结构
const matsuriEvent = {
  id: 'unique-identifier', // 唯一ID
  title: '祭典标题', // 主标题
  _sourceData: {
    // 原始数据源标记
    japaneseName: '日文名称',
    japaneseDescription: '日文描述',
  },
  englishName: 'English Name', // 英文名称
  name: '中文显示名称', // 中文名称
  date: '2025-MM-DD', // ISO日期格式
  dates: '用户友好日期显示', // 显示用日期
  endDate: '2025-MM-DD', // 结束日期(可选)
  location: '举办城市', // 地理位置
  venue: '具体场地名称', // 详细地址
  highlights: ['🎌 特色1', '🎭 特色2'], // 亮点特色
  features: ['🎌 特色1', '🎭 特色2'], // 功能特性
  likes: 数字, // 点赞数(真实数据)
  website: 'https://official.com', // 官方网站
  description: '详细活动描述', // 活动说明
  category: '祭典分类', // 事件分类
  prefecture: '都道府县', // 行政区域
  region: 'region-code', // 地区代码
};
```

### HanabiPageTemplate 使用规范

**适用场景:** 花火大会页面  
**数据来源:** walkerplus.com  
**核心特点:** 花火数量、观众数量、技术规格

```typescript
// 花火事件数据结构
const hanabiEvent = {
  // 基础信息 (与matsuri相同)
  id: 'unique-identifier',
  title: '花火大会名称',
  // ... 其他基础字段

  // 花火专属字段
  fireworks: '约2万发', // 花火发数
  expectedVisitors: '50万人', // 预期观众数
  dataSource: 'WalkerPlus', // 数据来源标注
  venue: '具体观赏地点', // 观赏最佳位置

  // 技术规格
  highlights: ['🎆 特大号花火', '🌟 连发表演'],
  category: '大型花火大会',
};
```

## 🎯 数据管理规范

### 数据真实性原则

**零编造政策:**

```typescript
// ❌ 严格禁止 - 编造数据
expectedVisitors: '480000',     // 无官方数据支撑
fireworks: '推测约3万发',       // 基于推测的数据
dataSource: 'estimated'        // 模糊的数据来源

// ✅ 正确做法 - 真实数据
likes: 412,                     // 来自omaturilink.com
website: 'https://official.jp', // 官方验证链接
description: '官方描述文本'      // 官方提供的描述
```

**数据来源标准:**

```typescript
// matsuri数据来源
Source: omaturilink.com
Validation: 官方祭典信息网站
Fields: title, date, location, description, highlights

// hanabi数据来源
Source: walkerplus.com
Validation: WalkerPlus官方花火数据
Fields: fireworks, expectedVisitors, venue, technical specs
```

### 数据结构验证

**质量检查标准:**

```bash
# 运行质量检查
npm run check-quality

# matsuri页面预期结果
❌ 花火大会数据结构: 缺少必要字段: fireworks  # 这是正确的！
❌ WalkerPlus数据源标注: 缺少WalkerPlus标注   # 这是正确的！

# hanabi页面预期结果
✅ 花火大会数据结构: 数据结构完整
✅ WalkerPlus数据源标注: 包含WalkerPlus数据源标注
```

## 🛠️ 开发工作流程

### 并行工具调用最佳实践

**高效开发策略:**

```javascript
// ✅ 推荐：并行工具调用 (3-5x效率)
<function_calls>
<invoke name="read_file">file1.tsx</invoke>
<invoke name="read_file">file2.tsx</invoke>
<invoke name="grep_search">pattern</invoke>
<invoke name="codebase_search">semantic_query</invoke>
</function_calls>

// ❌ 避免：串行调用 (效率低下)
read_file(file1) -> 等待结果 -> read_file(file2) -> 等待结果
```

**代码审查工具链:**

```javascript
// 1. 语义搜索 - 理解功能和上下文
codebase_search('matsuri page data structure');

// 2. 精确搜索 - 查找特定模式
grep_search('expectedVisitors|fireworks|dataSource');

// 3. 文件定位 - 快速找到相关文件
file_search('matsuri.*page');

// 4. 深度分析 - 详细检查代码
read_file('specific-component.tsx');
```

### 代码修改标准流程

**标准操作序列:**

1. **分析阶段:**

   ```bash
   # 运行质量检查了解现状
   npm run check-quality

   # 使用并行工具调用收集信息
   codebase_search + grep_search + file_search
   ```

2. **修改阶段:**

   ```javascript
   // 优先使用并行编辑
   edit_file(file1) + edit_file(file2) + edit_file(file3);

   // 大文件使用search_replace
   search_replace(large_file, old_pattern, new_pattern);
   ```

3. **验证阶段:**

   ```bash
   # 重新运行质量检查
   npm run check-quality

   # 分析结果，区分"真错误"和"预期差异"
   ```

## 📊 质量保证体系

### 自动化检查项目

**页面结构检查:**

- ✅ 模板组件正确使用
- ✅ 路由结构符合规范
- ✅ 文件命名一致性

**代码质量检查:**

- ✅ 无unused console.log
- ✅ 无硬编码URL
- ✅ 无空catch块
- ✅ React key属性完整
- ✅ 日文字符使用合理

**SEO优化检查:**

- ✅ Meta标题长度(30-60字符)
- ✅ Meta描述长度(120-160字符)
- ✅ OpenGraph标签完整
- ✅ 结构化数据标注

**数据完整性检查:**

- ✅ 必要字段完整性
- ✅ 数据来源标注清晰
- ✅ 数值合理性验证
- ✅ 一致性逻辑验证

### 错误分级与处理

**严重错误 (❌):**

- 影响页面功能的代码错误
- 数据编造或虚假信息
- 安全相关问题

**警告 (⚠️):**

- SEO优化建议
- 性能优化机会
- 代码风格不一致

**信息 (ℹ️):**

- 最佳实践建议
- 可选的改进方向

## 🔧 组件开发规范

### 静态数据组件模式

**推荐模式:**

```typescript
// 简洁的静态数据组件
'use client';
import TemplateComponent from '@/components/TemplateComponent';
import { Metadata } from 'next';

export const metadata: Metadata = { /* SEO配置 */ };

const regionConfig = { /* 地区配置 */ };
const eventsData = [ /* 静态事件数据 */ ];

export default function RegionActivity() {
  return (
    <TemplateComponent
      region={regionConfig}
      events={eventsData}
      pageTitle="SEO标题"
      pageDescription="SEO描述"
      regionKey="region"
      activityKey="activity"
    />
  );
}
```

**避免模式:**

```typescript
// ❌ 过度复杂的动态加载
export default function ComplexPage() {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // 复杂的API调用和错误处理
  }, []);

  // 大量状态管理逻辑...
}
```

### 命名规范

**文件命名:**

```
页面文件: page.tsx
组件文件: ComponentName.tsx
数据文件: region-activity-data.ts
文档文件: 0615+中文描述.md
```

**变量命名:**

```typescript
// 地区配置
const regionConfig = {
  /* ... */
};

// 事件数据
const regionActivityEvents = [
  /* ... */
];

// 组件props
interface TemplateProps {
  region: RegionConfig;
  events: EventData[];
  pageTitle: string;
  pageDescription: string;
}
```

## 🚀 性能优化原则

### 静态优先策略

- ✅ 静态数据 > 动态API调用
- ✅ 编译时生成 > 运行时计算
- ✅ 预构建内容 > 实时渲染

### 代码分割策略

- ✅ 页面级代码分割
- ✅ 组件按需加载
- ✅ 第三方库优化

### 资源优化

- ✅ 图片格式优化
- ✅ CSS样式合并
- ✅ 字体文件优化

---

_文档维护: 每个技术变更后更新_  
_责任人: 技术团队负责人_
