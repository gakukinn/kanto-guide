# 日本旅游指南网站技术架构详细文档

**文档版本**: v1.0  
**创建日期**: 2025年6月27日  
**技术负责**: AI Assistant  
**架构类型**: 混合渲染静态优先架构  

---

## 🏗️ 架构总览

### 设计理念
**混合渲染静态优先架构**: 根据数据特性和用户需求选择最适合的渲染方式，优化性能和用户体验。

```
架构特点:
├── 静态优先: 最大化静态内容，减少服务器负载
├── 混合渲染: SSG + SSR，各取所长
├── 数据驱动: 基于JSON文件的数据管理
└── 组件化: 可复用的React组件系统
```

### 核心技术选择

#### 前端框架
```typescript
// Next.js 14 - 现代React框架
const frameworkFeatures = {
  appRouter: "App Router架构，支持嵌套布局",
  serverComponents: "React Server Components，优化性能",
  staticGeneration: "静态站点生成，SEO友好",
  serverSideRendering: "服务端渲染，动态数据支持",
  apiRoutes: "内置API路由，后端功能集成"
};
```

#### 开发语言
```typescript
// TypeScript - 类型安全的JavaScript
interface TechStack {
  language: "TypeScript 5.x";
  benefits: [
    "编译时类型检查",
    "更好的IDE支持",
    "代码可维护性",
    "团队协作效率"
  ];
  configuration: "严格模式，全项目覆盖";
}
```

#### 样式系统
```css
/* Tailwind CSS - 实用优先的CSS框架 */
.advantages {
  @apply 
    /* 快速开发 */ rapid-development
    /* 一致性设计 */ consistent-design  
    /* 响应式布局 */ responsive-layout
    /* 优化构建 */ optimized-build;
}
```

#### 数据库与ORM
```prisma
// Prisma + SQLite - 现代数据库工具链
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

// 优势:
// 1. 类型安全的数据库访问
// 2. 自动生成的客户端
// 3. 数据库迁移管理
// 4. 直观的Schema定义
```

---

## 📱 页面架构设计

### 渲染策略

#### 四层页面架构
```
渲染策略分层:
├── Layer 1: 首页 (/) 
│   └── 渲染方式: 静态生成 (SSG)
│   └── 数据源: 硬编码配置
│
├── Layer 2: 地区首页 (/tokyo, /saitama, ...)
│   └── 渲染方式: 静态生成 (SSG)  
│   └── 数据源: 静态配置文件
│
├── Layer 3: 活动列表页 (/tokyo/hanabi, /saitama/matsuri, ...)
│   └── 渲染方式: 服务端渲染 (SSR)
│   └── 数据源: JSON文件动态读取
│
└── Layer 4: 活动详情页 (/tokyo/hanabi/activity-xxx, ...)
    └── 渲染方式: 静态生成 (SSG)
    └── 数据源: 页面内硬编码
```

#### 渲染方式选择逻辑
```typescript
// 渲染方式决策树
const renderingStrategy = (pageType: string, dataFrequency: string) => {
  if (pageType === 'detail' && dataFrequency === 'static') {
    return 'SSG'; // 详情页，数据不常变更
  }
  if (pageType === 'list' && dataFrequency === 'dynamic') {
    return 'SSR'; // 列表页，数据可能更新
  }
  if (pageType === 'landing' && dataFrequency === 'static') {
    return 'SSG'; // 首页，配置相对固定
  }
  return 'SSR'; // 默认服务端渲染
};
```

### 路由设计

#### 动态路由结构
```typescript
// app目录结构映射到URL路由
const routeMapping = {
  '/': 'app/page.tsx',                    // 首页
  '/[region]': 'app/[region]/page.tsx',   // 地区首页
  '/[region]/[activity]': 'app/[region]/[activity]/page.tsx', // 活动列表
  '/[region]/[activity]/[activityId]': 'app/[region]/[activity]/[activityId]/page.tsx' // 详情页
};

// 参数验证
const validateParams = (region: string, activity: string) => {
  const validRegions = ['tokyo', 'saitama', 'chiba', 'kanagawa', 'kitakanto', 'koshinetsu'];
  const validActivities = ['hanabi', 'hanami', 'matsuri', 'momiji', 'illumination', 'culture'];
  
  return validRegions.includes(region) && validActivities.includes(activity);
};
```

---

## 🗄️ 数据架构

### 数据库设计

#### 核心实体模型
```prisma
// 地区实体
model Region {
  id        String   @id @default(cuid())
  code      String   @unique // tokyo, saitama, etc.
  nameCn    String   // 中文名称
  nameJp    String   // 日文名称
  emoji     String   // 表情符号
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 活动实体（以花火为例，其他5种活动结构相同）
model HanabiEvent {
  id          String   @id @default(cuid())
  region      String   // 地区代码
  detailLink  String?  // 详情页链接
  
  // Jalan十项标准字段
  name        String   // 1. 活动名称
  address     String   // 2. 所在地址
  datetime    String   // 3. 开催时间
  venue       String   // 4. 开催场所
  access      String   // 5. 交通方式
  organizer   String   // 6. 主办方
  price       String   // 7. 费用信息
  contact     String   // 8. 联系方式
  website     String   // 9. 官方网站
  googleMap   String   // 10. 地图链接
  
  // 扩展字段
  description String?  // 活动描述
  status      String   @default("active")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([region, status])
}
```

#### 数据一致性保证
```typescript
// 数据验证接口
interface DataValidation {
  jalanStandards: {
    requiredFields: string[];
    optionalFields: string[];
    validation: (data: any) => boolean;
  };
  linkConsistency: {
    detailLinkFormat: RegExp;
    pathValidation: (link: string) => boolean;
  };
}

// 实现
const validateActivityData = (data: ActivityData): ValidationResult => {
  const requiredFields = ['name', 'address', 'datetime', 'venue', 'access', 
                          'organizer', 'price', 'contact', 'website', 'googleMap'];
  
  const missingFields = requiredFields.filter(field => !data[field]);
  const isValidLink = /^\/[a-z]+\/[a-z]+\/activity-\d{8}$/.test(data.detailLink);
  
  return {
    isValid: missingFields.length === 0 && isValidLink,
    missingFields,
    linkValid: isValidLink
  };
};
```

### JSON数据结构

#### 文件组织
```
data/
└── regions/
    ├── tokyo/
    │   ├── hanabi.json      # 东京花火活动
    │   ├── hanami.json      # 东京花见活动
    │   └── matsuri.json     # 东京祭典活动
    ├── saitama/
    │   ├── hanabi.json
    │   ├── hanami.json
    │   └── matsuri.json
    └── ... (其他地区)
```

#### JSON数据格式
```typescript
// 标准JSON数据结构
interface RegionActivityData {
  metadata: {
    region: string;
    activity: string;
    lastUpdated: string;
    version: string;
  };
  activities: ActivityItem[];
}

interface ActivityItem {
  id: string;
  title: string;
  description: string;
  detailLink: string;
  imageUrl?: string;
  
  // Jalan十项标准信息
  jalanData: {
    name: string;
    address: string;
    datetime: string;
    venue: string;
    access: string;
    organizer: string;
    price: string;
    contact: string;
    website: string;
    googleMap: string;
  };
}
```

---

## 🔧 组件架构

### 组件分层

#### 组件层次结构
```
组件架构:
├── Pages (页面层)
│   ├── HomePage
│   ├── RegionPage  
│   ├── ActivityListPage
│   └── ActivityDetailPage
│
├── Templates (模板层)
│   ├── UniversalStaticPageTemplate
│   ├── HanabiDetailTemplate
│   ├── MatsuriDetailTemplate
│   └── HanamiDetailTemplate
│
├── Components (组件层)
│   ├── Navigation
│   ├── ActivityCard
│   ├── RegionSelector
│   └── Footer
│
└── UI (基础UI层)
    ├── Button
    ├── Card
    ├── Modal
    └── Form
```

#### 核心模板组件
```typescript
// 通用静态页面模板
interface UniversalStaticPageTemplateProps {
  region: RegionConfig;
  events: ActivityItem[];
  regionKey: string;
  activityKey: string;
  activityDisplayName: string;
  activityEmoji: string;
}

const UniversalStaticPageTemplate: React.FC<UniversalStaticPageTemplateProps> = ({
  region,
  events,
  regionKey,
  activityKey,
  activityDisplayName,
  activityEmoji
}) => {
  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50">
      <Navigation region={region} />
      <ActivityList 
        events={events}
        activityType={activityDisplayName}
        emoji={activityEmoji}
      />
      <Footer />
    </div>
  );
};
```

### 状态管理

#### 状态管理策略
```typescript
// 简单状态管理 - React内置Hook
const useActivityData = (region: string, activity: string) => {
  const [data, setData] = useState<ActivityItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(`/api/activities/${region}/${activity}`);
        const result = await response.json();
        setData(result.activities);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [region, activity]);
  
  return { data, loading, error };
};
```

---

## 🚀 性能优化

### 静态优化

#### 构建时优化
```typescript
// Next.js配置优化
const nextConfig = {
  // 静态导出配置
  trailingSlash: true,
  
  // 图片优化
  images: {
    unoptimized: true, // 静态导出时禁用图片优化
  },
  
  // 编译优化
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },
  
  // 实验性功能
  experimental: {
    appDir: true,
  },
};
```

#### 代码分割
```typescript
// 动态导入实现代码分割
const AdminPanel = dynamic(() => import('../components/AdminPanel'), {
  loading: () => <div>Loading...</div>,
  ssr: false, // 管理面板不需要SSR
});

const ActivityMap = dynamic(() => import('../components/ActivityMap'), {
  loading: () => <div>Loading map...</div>,
});
```

### 运行时优化

#### 缓存策略
```typescript
// API路由缓存
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const region = searchParams.get('region');
  const activity = searchParams.get('activity');
  
  // 设置缓存头
  const headers = {
    'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',
    'Content-Type': 'application/json',
  };
  
  const data = await getActivityData(region, activity);
  
  return new Response(JSON.stringify(data), { headers });
}
```

#### 资源优化
```typescript
// 图片懒加载
const OptimizedImage: React.FC<ImageProps> = ({ src, alt, ...props }) => {
  return (
    <Image
      src={src}
      alt={alt}
      loading="lazy"
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,..."
      {...props}
    />
  );
};
```

---

## 🔐 安全与错误处理

### 数据验证

#### 输入验证
```typescript
// Zod schema验证
import { z } from 'zod';

const ActivityDataSchema = z.object({
  name: z.string().min(1).max(100),
  address: z.string().min(1),
  datetime: z.string().min(1),
  venue: z.string().min(1),
  access: z.string().min(1),
  organizer: z.string().min(1),
  price: z.string().min(1),
  contact: z.string().min(1),
  website: z.string().url(),
  googleMap: z.string().url(),
});

// API路由中使用
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const validatedData = ActivityDataSchema.parse(body);
    
    // 处理验证通过的数据
    const result = await saveActivityData(validatedData);
    return Response.json(result);
    
  } catch (error) {
    if (error instanceof z.ZodError) {
      return Response.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }
    
    return Response.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### 错误边界

#### React错误边界
```typescript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>Something went wrong</h2>
          <details>
            {this.state.error && this.state.error.toString()}
          </details>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

---

## 📊 监控与分析

### 性能监控

#### Core Web Vitals
```typescript
// 性能指标收集
export function reportWebVitals(metric) {
  switch (metric.name) {
    case 'CLS':
    case 'FID':
    case 'FCP':
    case 'LCP':
    case 'TTFB':
      // 发送到分析服务
      analytics.track('Web Vital', {
        name: metric.name,
        value: metric.value,
        id: metric.id,
      });
      break;
    default:
      break;
  }
}
```

### 错误追踪

#### 错误日志系统
```typescript
// 错误日志收集
const logger = {
  error: (message: string, error?: Error) => {
    console.error(message, error);
    
    // 发送到错误追踪服务
    if (process.env.NODE_ENV === 'production') {
      errorTracker.captureException(error || new Error(message));
    }
  },
  
  warn: (message: string) => {
    console.warn(message);
  },
  
  info: (message: string) => {
    console.info(message);
  }
};
```

---

## 🛠️ 开发工具链

### 代码质量

#### ESLint配置
```json
{
  "extends": [
    "next/core-web-vitals",
    "@typescript-eslint/recommended"
  ],
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/no-explicit-any": "warn",
    "prefer-const": "error",
    "no-console": "warn"
  }
}
```

#### Prettier配置
```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2
}
```

### 测试策略

#### 测试类型
```typescript
// 单元测试 - Jest + Testing Library
describe('ActivityCard Component', () => {
  it('renders activity information correctly', () => {
    const mockActivity = {
      id: '1',
      title: 'Test Activity',
      description: 'Test Description',
      detailLink: '/test/link'
    };
    
    render(<ActivityCard activity={mockActivity} />);
    
    expect(screen.getByText('Test Activity')).toBeInTheDocument();
    expect(screen.getByText('Test Description')).toBeInTheDocument();
  });
});

// 集成测试
describe('Activity API', () => {
  it('returns activity data for valid region and activity', async () => {
    const response = await fetch('/api/activities/tokyo/hanabi');
    const data = await response.json();
    
    expect(response.status).toBe(200);
    expect(data.activities).toBeDefined();
    expect(Array.isArray(data.activities)).toBe(true);
  });
});
```

---

## 🔧 数据提取技术

### 地图坐标提取技术 (Playwright + Cheerio)

#### 技术背景
使用Playwright浏览器自动化+Cheerio HTML解析技术，从Jalan官方网站精确提取地图坐标信息，确保位置信息的准确性。

#### 核心实现
```javascript
// 多方法坐标提取策略
const extractCoordinates = async (page) => {
  // 方法1: iframe地图分析
  const iframeCoords = await page.evaluate(() => {
    const iframes = Array.from(document.querySelectorAll('iframe'));
    for (const iframe of iframes) {
      const src = iframe.src;
      if (src && (src.includes('maps.google') || src.includes('google.com/maps'))) {
        const coordsMatch = src.match(/[!@]([0-9.-]+),([0-9.-]+)/);
        if (coordsMatch) {
          return { lat: parseFloat(coordsMatch[1]), lng: parseFloat(coordsMatch[2]) };
        }
      }
    }
  });

  // 方法2: JavaScript变量搜索
  const jsCoords = await page.evaluate(() => {
    const scripts = Array.from(document.querySelectorAll('script'));
    for (const script of scripts) {
      const text = script.textContent || '';
      const patterns = [
        /lat[:\s]*([0-9.]+)[\s,]*lng[:\s]*([0-9.]+)/gi,
        /latitude[:\s]*([0-9.]+)[\s,]*longitude[:\s]*([0-9.]+)/gi,
      ];
      // 日本坐标范围验证: lat(30-40), lng(135-145)
    }
  });

  // 方法3: 链接坐标提取 ⭐ (最可靠方法)
  const linkCoords = await page.evaluate(() => {
    const links = Array.from(document.querySelectorAll('a[href*="maps"], a[href*="google"]'));
    for (const link of links) {
      const href = link.href;
      const patterns = [
        /@([0-9.-]+),([0-9.-]+)/,
        /ll=([0-9.-]+),([0-9.-]+)/,
        /center=([0-9.-]+),([0-9.-]+)/,
        /q=([0-9.-]+),([0-9.-]+)/
      ];
      for (const pattern of patterns) {
        const match = href.match(pattern);
        if (match) {
          const lat = parseFloat(match[1]);
          const lng = parseFloat(match[2]);
          // 验证坐标在日本范围内
          if (lat >= 30 && lat <= 40 && lng >= 135 && lng <= 145) {
            return { lat, lng, source: 'Google Maps link' };
          }
        }
      }
    }
  });

  // 按优先级返回结果
  return linkCoords || iframeCoords || jsCoords || null;
};
```

#### 成功案例
- **成田祇園祭坐标提取**: 从估算值35.7779, 140.3168提升到官方精确值35.786063, 140.318295
- **精度提升**: 约800米的位置偏差修正
- **数据来源**: Google Maps官方链接验证

### Jalan十项标准数据结构

#### 数据标准定义
```typescript
interface JalanStandardData {
  name: string;        // 1. 活动名称
  address: string;     // 2. 所在地址  
  datetime: string;    // 3. 开催时间（日期+时间段合并）
  venue: string;       // 4. 开催场所
  access: string;      // 5. 交通方式
  organizer: string;   // 6. 主办方
  price: string;       // 7. 费用信息
  contact: string;     // 8. 联系方式
  website: string;     // 9. 官方网站
  googleMap: string;   // 10. 地图链接/坐标
}
```

#### 数据验证机制
```typescript
const validateJalanData = (data: JalanStandardData): ValidationResult => {
  const requiredFields = ['name', 'address', 'datetime', 'venue', 'access', 
                          'organizer', 'price', 'contact', 'website', 'googleMap'];
  
  const missingFields = requiredFields.filter(field => !data[field]);
  
  // 坐标格式验证
  const coordsValid = /^[0-9.-]+,[0-9.-]+$/.test(data.googleMap) || 
                     /^https:\/\/maps\.google/.test(data.googleMap);
  
  // 网站URL验证
  const websiteValid = /^https?:\/\//.test(data.website);
  
  return {
    isValid: missingFields.length === 0 && coordsValid && websiteValid,
    missingFields,
    coordsValid,
    websiteValid
  };
};
```

---

## 🔮 架构演进计划

### 近期优化（1-2个月）
1. **性能优化**
   - 实现更细粒度的代码分割
   - 优化图片加载策略
   - 实现Service Worker缓存

2. **开发体验**
   - 完善TypeScript类型定义
   - 增加更多单元测试
   - 优化构建流程

### 中期演进（3-6个月）
1. **架构升级**
   - 考虑引入状态管理库（如Zustand）
   - 实现更复杂的缓存策略
   - 微前端架构探索

2. **功能扩展**
   - 实现实时数据同步
   - 添加用户个性化功能
   - 集成第三方服务

### 长期规划（6个月+）
1. **技术栈演进**
   - 考虑迁移到最新的React特性
   - 探索边缘计算部署
   - 实现全栈TypeScript

2. **架构重构**
   - 微服务架构设计
   - 数据库分离与优化
   - API网关实现

---

**架构维护**: 本文档应随着技术栈更新和架构演进及时更新，确保技术决策的透明性和可追溯性。 